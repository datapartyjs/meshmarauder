#!/usr/bin/env bash

DEVICE=""
PRESET=()
INTERVAL=60
INIT_ONLY=0
DEBUG=0

usage() {
    echo "Usage: $0 [-D DEVICE] [-p PRESET]... [-i INTERVAL] [-h]"
    echo
    echo "Options:"
    echo "  -D DEVICE     Serial Device of lorapipe radio (required)"
    echo "  -I            Initialize radio, set first specified preset, and " \
         "exit"
    echo "  -p PRESET     LoRA Radio Preset String (one or more required)"
    echo "  -i INTERVAL   Interval in seconds between switching between the " \
         "specified presets (default 60)"
    echo "  -h            Show this help message and exit"
    exit 1
}

error_exit() {
    echo "Error: $1" >&2
    usage
    exit 1
}

error_echo() {
    echo "[$0] [ERROR] $1" >&2
}

debug_echo() {
    echo "[$0] [DEBUG] $1" >&2
}

# Parse arguments
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        -D)
            shift
            [[ -z "$1" || "$1" =~ ^- ]] && error_exit "Missing value for -D"
            [[ ! -e "$1" ]] && error_exit "Device '$1' does not exist."
            DEVICE="$1"
            ;;
        -I)
            INIT_ONLY=1
            ;;
        -i)
            shift
            [[ -z "$1" || "$1" =~ ^- ]] && error_exit "Missing value for -i"
            [[ ! -n "$1" ]] && error_exit "Interval must be an integer: got '$1'"
            INTERVAL="$1"
            ;;
        -p)
            shift
            [[ -z "$1" || "$1" =~ ^- ]] && error_exit "Missing value for -p"
            PRESET+=("$1")
            ;;
        -h|--help)
            usage
            ;;
        *)
            error_exit "Unknown option: $1"
            ;;
    esac
    shift
done

# Validate required arguments
if [[ -z "$DEVICE" ]]; then
    error_exit "Device argument was not specified after -D"
fi

if [[ ${#PRESET[@]} -eq 0 ]]; then
    error_exit "At least one -p (preset) value is required."
fi

# Do the thing
exec 3<> "$DEVICE"  # Shove device into a file descriptor

# Utility methods
clear_buffer() {
    while true; do
        if read -t 0 -u 3; then
            IFS= read -r -t 1 -u 3 line
            [[ $DEBUG -eq 1 ]] && debug_echo "clear_buffer line: ${line}"
        else
            [[ $DEBUG -eq 1 ]] && debug_echo "clear_buffer: nothing to read"
            break
        fi
    done
}

send_cmd() {
    clear_buffer
    cmd=$1
    printf "$cmd\r\n" >&3
    [[ $DEBUG -eq 1 ]] && debug_echo "command sent: $cmd"

    IFS= read -r -t 1 -u 3 line
    [[ $DEBUG -eq 1 ]] && debug_echo "command received: $line"

    IFS= read -r -t 1 -u 3 line
    [[ $DEBUG -eq 1 ]] && debug_echo "command response: $line"

    echo $(echo $line | tr -d '\r')
}

rxlog() {
    if [ $1 = true ]; then
        resp=$(send_cmd "rxlog on")
        [[ "$resp" == "-> rxlog on" ]] && return 0 || return 1
    else
        resp=$(send_cmd "rxlog off")
        if [[ "$resp" == "-> rxlog off" ]]; then 
            return 0
        else
            clear_buffer
            return 1
        fi
    fi
}

change_preset() {
    rxlog false
    resp=$(send_cmd "set radio $1")
    [[ ! "$resp" =~ OK$ ]] && error_echo "$resp"

    timestamp=$(date +%s)
    radio_resp=$(send_cmd "get radio")
    rxlog true

    # loosely matches something that looks like this at the end of the line
    # 906.875,250.0,11,5,0xb2
    regex='([0-9.]+,[0-9.]+,[0-9]+,[0-9]+,0x[0-9a-fA-F]{2})$'
    if [[ "$radio_resp" =~ $regex ]]; then
        radio_preset=${BASH_REMATCH[1]}
        echo "$timestamp,RADIO_PRESET,$radio_preset"
        return 0
    else
        echo "$timestamp,RADIO_PRESET,UNKNOWN RESPONSE,$resp"
        return 1
    fi
}

set_clock() {
    timestamp=$(date +%s)
    resp=$(send_cmd "time $timestamp")
    regex='^-> OK - (.+)$'
    if [[ "$resp" =~ $regex ]]; then
        clock_time=${BASH_REMATCH[1]}
        echo "$timestamp,SET_CLOCK,$clock_time"
        return 0
    else
        error_echo "$resp"
        return 1
    fi
}

get_clock() {
    imestamp=$(date +%s)
    resp=$(send_cmd "clock")
    regex='^-> (.+)$'
    if [[ "$resp" =~ $regex ]]; then
        clock_time=${BASH_REMATCH[1]}
        echo "$timestamp,GET_CLOCK,$clock_time"
        return 0
    else
        error_echo "$resp"
        return 1
    fi
}

serial_port_loop() {
    clear_buffer
    [[ $DEBUG -eq 1 ]] && debug_echo "beginning serial port read loop"
    while IFS= read -r -u 3 line; do
        # read fd3 which is a fh on $DEVICE
        [[ $line =~ ^[0-9]{5}+ ]]; echo "$line"
        [[ $DEBUG -eq 1 && ! $line =~ ^[0-9]{5}+ ]] && \
            debug_echo "[SERIAL] $line"
        [[ $DEBUG -eq 1 ]] && debug_echo "waiting for next line"
    done
}

preset_idx=0
init_scanner() {
    stty -F ${DEVICE} raw
    stty -F ${DEVICE} -echo
    rxlog false # will be re-enabled initially in change_preset
    set_clock
    get_clock
    change_preset ${PRESET[0]} # set initial preset
    [[ ! $INIT_ONLY -eq 0 ]] && echo "[$0] Exiting after initialization due to -I" && exit 0
    preset_idx=1 # initialize preset_idx counter to begin on the second value
}

run_periodic_command() {  # Run me every interval!
    # only run if more than one preset specififed
    if [[ ${#PRESET[@]} -gt 1 ]]; then
        change_preset ${PRESET[$preset_idx]}
        # Move to the next value in the array, cycling back to the
        # first value if at the end
        ((preset_idx = (preset_idx + 1) % ${#PRESET[@]}))
    fi
}

cleanup() {
    echo "[$0] killing child processes and exiting"
    kill "$loop_pid" 2>/dev/null
    exit 0
}

trap cleanup EXIT INT # trap exit signals and call cleanup

init_scanner
serial_port_loop & # fork a serial port loop
loop_pid=$! # store the forked processes pid

last_trigger_time=$(date +%s)  # Set start time

stdin_cmd() {
    timestamp=$(date +%s)
    resp=$(send_cmd "$2") # send line as raw command, get reply
    echo "$timestamp,$1,$resp" # show the reply in our stdout
}

while true; do
    now=$(date +%s)
    elapsed=$((now - last_trigger_time))
    if read -t 0; then # non-blocking check for anything to read on our stdin
        kill -STOP $loop_pid # halt the main read loop
        while IFS= read -r line; do
            txraw_regex='^txraw [0-9a-fA-F]+$'
            rxlog_regex='^rxlog (on|off)$'
            if [[ "$line" =~ $txraw_regex ]]; then
                stdin_cmd "TXRAW" "$line"
            elif [[ "$line" =~ $rxlog_regex ]]; then
                stdin_cmd "RXLOG_OUT" "$line"
            fi
        done
        kill -CONT $loop_pid # continue the main read loop
    fi
    if [[ "$elapsed" -ge "$INTERVAL" ]]; then
        kill $loop_pid # kill the reading process
        wait $loop_pid # wait for it to terminate

        run_periodic_command
        last_trigger_time=$now

        serial_port_loop & # fork a serial port loop
        loop_pid=$! # store the forked processes pid
    fi
done
